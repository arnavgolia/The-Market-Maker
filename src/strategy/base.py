"""
Base strategy interface and signal definitions.

All strategies must implement the Strategy protocol.
Signals are generated by strategies and consumed by the execution engine.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Optional
import structlog

logger = structlog.get_logger(__name__)


class SignalType(Enum):
    """Type of trading signal."""
    BUY = "buy"
    SELL = "sell"
    CLOSE = "close"  # Close existing position
    HOLD = "hold"    # No action


@dataclass
class Signal:
    """
    A trading signal generated by a strategy.
    
    Signals are recommendations, not orders. The execution engine
    decides whether to act on them based on risk management.
    """
    symbol: str
    signal_type: SignalType
    timestamp: datetime
    
    # Strategy attribution
    strategy_name: str
    signal_id: str  # Unique ID for this signal
    
    # Signal strength (0.0 to 1.0)
    confidence: float = 0.5
    
    # Suggested position size (as % of portfolio)
    suggested_size_pct: Optional[float] = None
    
    # Entry/exit levels
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    
    # Metadata
    metadata: dict = None
    
    def __post_init__(self):
        """Initialize metadata if not provided."""
        if self.metadata is None:
            self.metadata = {}
    
    def to_dict(self) -> dict:
        """Convert to dictionary for logging/storage."""
        return {
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "timestamp": self.timestamp.isoformat(),
            "strategy_name": self.strategy_name,
            "signal_id": self.signal_id,
            "confidence": self.confidence,
            "suggested_size_pct": self.suggested_size_pct,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "metadata": self.metadata,
        }


class Strategy(ABC):
    """
    Base strategy interface.
    
    All strategies must:
    1. Implement generate_signals()
    2. Check regime before generating signals
    3. Respect enable/disable flags
    4. Log all signal generation
    """
    
    def __init__(
        self,
        name: str,
        enabled: bool = True,
        require_regime: bool = True,
    ):
        """
        Initialize strategy.
        
        Args:
            name: Strategy name (for attribution)
            enabled: Whether strategy is enabled
            require_regime: If True, only generate signals when regime allows
        """
        self.name = name
        self.enabled = enabled
        self.require_regime = require_regime
        
        logger.info(
            "strategy_initialized",
            name=name,
            enabled=enabled,
            require_regime=require_regime,
        )
    
    @abstractmethod
    def generate_signals(
        self,
        symbol: str,
        bars: any,  # DataFrame or list of Bar objects
        current_regime: Optional[any] = None,  # MarketRegime
        current_position: Optional[dict] = None,
    ) -> list[Signal]:
        """
        Generate trading signals for a symbol.
        
        Args:
            symbol: Stock symbol
            bars: Historical price bars
            current_regime: Current market regime (if available)
            current_position: Current position (if any)
        
        Returns:
            List of signals (may be empty)
        """
        pass
    
    def should_generate_signals(
        self,
        current_regime: Optional[any] = None,
    ) -> bool:
        """
        Check if strategy should generate signals.
        
        This checks:
        - Strategy is enabled
        - Regime allows trading (if require_regime=True)
        """
        if not self.enabled:
            return False
        
        if self.require_regime and current_regime:
            # Check if regime allows momentum strategies
            # For demo/active trading, be less restrictive
            if hasattr(current_regime, "momentum_enabled"):
                # Only disable if we're in a clear CRISIS mode
                if (not current_regime.momentum_enabled and 
                    hasattr(current_regime, "volatility") and
                    current_regime.volatility.value == "crisis"):
                    logger.debug(
                        "strategy_disabled_by_crisis",
                        strategy=self.name,
                        regime=current_regime.combined_regime,
                    )
                    return False
                # Allow strategies even if momentum_enabled is False (for mean reversion)
                # The individual strategies will check their own requirements
        
        return True
    
    def validate_signal(self, signal: Signal) -> bool:
        """
        Validate a signal before it's used.
        
        Override this in subclasses for custom validation.
        """
        if signal.confidence < 0.0 or signal.confidence > 1.0:
            logger.warning(
                "invalid_signal_confidence",
                signal_id=signal.signal_id,
                confidence=signal.confidence,
            )
            return False
        
        return True
    
    def __repr__(self) -> str:
        return f"Strategy(name={self.name}, enabled={self.enabled})"
